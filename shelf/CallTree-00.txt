Call Tree in Shelf/main.py and friends

RBLandau 20140804

#=================================================
# Class methods defined

class CAudit
    def __init__
    def mAuditCycle
    def mAuditCollection
    def mRetrieveDoc
    def mRepairDoc
    def mReportAuditStats
class CDocument
    def __init__
    def mCopyPlacedOnServer
    def mTestCopies
    def mDocTestOneServer
class CCollection
    def __init__
    def mMakeBooks
    def mListDocuments
    def mTestCollection
    def mHowManyCopiesLeft
    def mIsDocInServer
    def mHowManyCopiesLeftOfThisOneDoc
            def mTestDocInServer(self,docID,serverID)
class CClient
    def __init__
    def mPlaceCollection
    def mSelectServersForCollection
    def mTestClient
    def mDocFailedOnServer
    def mDocReplaceOnServer
    def mCollectionTestAll
    def mDocPermanentFailure
class CNewTrace:
    def __init__
    def setDefaults
    def trace
    def tracef
    def wrap2
    def tracefinner
        def wrap1
        def somefunction()
class CRepair
    def __init__
    def mAuditCycle
    def mAuditNextCollection
    def mAuditCollection
    def mDocAuditAllDocsOnServer
    def mDocAuditOnAllServers
    def mDocAuditOneDocOnServer
class CCommand
    class CCommand: Execute a CLI command, parse results
    def doCmdStr
    def doCmdLst
    def doParse
    def makeCmd
class CServer
    def __init__
    def mAddCollection
    def mAddDocument
    def mCreateShelf
    def mDestroyDocument
    def mTestDocument
class CShelf
    def __init__
    def mAcceptDocument
    def mAddDocument
    def mAge_sector
    def mSelectVictimCopy
    def mSelectVictimCopy
    def mDestroyCopy
    def mAge_shelf
    def mReportDocumentLost
    def mReportUseStats
    def mReportErrorStats
class CCopy
    def __init__
    def mShelveCopy

#=================================================
# Call tree extracted from code

****** file  audit.py
class CAudit(object):
    def mAuditCycle(self,mynInterval):
    def mAuditCollection(self,mysCollectionID):
            lDocIDs = cCollection.mListDocuments()
                fTransferTime = self.mRetrieveDoc(sDocID)
                    nCopiesLeft = cCollection.mHowManyCopiesLeftOfThisOneDoc(sDocID)
                            fTransferTime = self.mRepairDoc(sDocID)
                            fTransferTime = self.mRepairDoc(sDocID)
    def mRetrieveDoc(self,mysDocID):
        fTransferTime = fnfCalcTransferTime(nDocSize,G.nBandwidthMbps)
        bResult = cServer.mTestDocument(mysDocID)
    def mRepairDoc(self,mysDocID):
        fTransferTime = fnfCalcTransferTime(nDocSize,G.nBandwidthMbps)
        cServer.mAddDocument(mysDocID,self.sClientID)
    def mReportAuditStats(self):

****** file  client.py
class CDocument(object):
    def __init__(self,size,mysClientID):
    def mCopyPlacedOnServer(self,mysCopyID,mysServerID):
    def mTestCopies(self):
            bResult = self.mDocTestOneServer(sServerID)
    def mDocTestOneServer(self,mysServerID):
        bResult = cServer.mTestDocument(self.ID)
class CCollection(object):
    def __init__(self,mysName,mynValue,mynSize,mysClientID):
        self.mMakeBooks(mynSize)
    def mMakeBooks(self,mynBooks):
            ndocsize = fnnCalcDocSize(self.nValue)
            cDoc = CDocument(ndocsize,self.sClientID)
    def mListDocuments(self):
    def mTestCollection(self):
            bResult = cDoc.mTestCopies()
    def mHowManyCopiesLeft(self):
                            self.mIsDocInServer(sDocID,sServerID)), \
    def mIsDocInServer(self,mysDocID,mysServerID):
        bResult = cServer.mTestDocument(mysDocID)
    def mHowManyCopiesLeftOfThisOneDoc(self,mysDocID):
                            self.mIsDocInServer(mysDocID,sServerID)), \
        def mTestDocInServer(self,docID,serverID)
            inner: len(filter( self.mTestDocInServer(docID,serverID), self.lServerIDs ))
class CClient(object):
    def __init__(self,mysName,mylCollections):
            cColl = CCollection(sCollName,nCollValue,nCollSize, self.ID)
            self.mPlaceCollection(sCollID)
        self.cRepair = CRepair(self.ID)
    def mPlaceCollection(self,mysCollID):
        lServersForCollection = self.mSelectServersForCollection(nCollValue)
            cServer.mAddCollection(mysCollID,self.ID)
                self.cAudit = CAudit(self.ID,mysCollID,sServerID,G.nAuditCycleInterval)
    def mSelectServersForCollection(self,mynCollValue):
    def mTestClient(self):
            lResult = cColl.mTestCollection()
    def mDocFailedOnServer(self,mysDocID,mysServerID):
        bResult = self.mDocFindValidCopy(mysDocID)
            self.mDocReplaceOnServer(mysDocID,mysServerID)
            self.mDocPermanentFailure(mysDocID)
    def mDocReplaceOnServer(self,mysDocID,mysServerID):
        cServer.mAddDocument(mysDocID,self.ID)
    def mCollectionTestAll(self,mysCollID):
    def mDocPermanentFailure(self,mysDocID):

****** file  cliparse.py
def fndCliParse(mysArglist):
        (xx) = cParse.parse_args(mysArglist)
        (xx) = cParse.parse_args()

****** file  logoutput.py
logger = logging.getLogger("LGOU")
def logSetConfig(mysLogLevel,mysLogFile):
        channel = logging.FileHandler(mysLogFile)
        channel = logging.StreamHandler()
    formatter = logging.Formatter(fmt='%(asctime)s %(name)s %(levelname)s - %(message)s', datefmt='%Y%m%d_%H%M%S')
    channel.setFormatter(formatter)
    logger.addHandler(channel)
        LOGME = logoutput.getLogger(__name__)
        LOGME.debug('debug message')
        LOGME.info('info message')
        LOGME.warn('warning message')
        LOGME.error('error message')
        LOGME.critical('critical message')
def getLogger(myname):
        logger.info(mystring)
def logDebug(myname,mystring):
    logger.debug(mystring)
def logError(myname,mystring):
    logger.error(mystring)
def logCritical(myname,mystring):
    logger.critical(mystring)

****** file  main.py
def getParamFiles(mysParamdir):
    dResult =   readin.fdGetClientParams("%s/clients.csv"%(mysParamdir))
    dResult =   readin.fdGetServerParams("%s/servers.csv"%(mysParamdir))
    dResult =    readin.fdGetQualityParams("%s/quality.csv"%(mysParamdir))
    dResult =   readin.fdGetParamsParams("%s/params.csv"%(mysParamdir))
    dResult =   readin.fdGetDistnParams("%s/distn.csv"%(mysParamdir))
    dResult =   readin.fdGetDocParams("%s/docsize.csv"%(mysParamdir))
    dResult =   readin.fdGetAuditParams("%s/audit.csv"%(mysParamdir))
        P.nRandomSeed = fnIntPlease(P.dParamsParams["RANDOMSEED"][0][0])
        P.nSimLength = fnIntPlease(P.dParamsParams["SIMLENGTH"][0][0])
        fnMaybeOverride("nAuditCycleInterval",P.dAuditParams,G)
        fnMaybeOverride("nBandwidthMbps",P.dAuditParams,G)
        P.nAuditCycleInterval = fnIntPlease(P.dAuditParams["nAuditCycleInterval"][0][0])
def getEnvironmentParams():
        P.nRandomSeed = fnIntPlease(environ["RANDOMSEED"])
        P.nSimLength = fnIntPlease(environ["SIMLENGTH"])
def getCliArgsForParamDirs():
    dCliDict = fndCliParse(None)
def getCliArgsForEverythingElse():
    G.dClientParams =   copy.deepcopy(P.dClientParams)
    G.dServerParams =   copy.deepcopy(P.dServerParams)
    G.dShelfParams =    copy.deepcopy(P.dShelfParams)
    G.dDistnParams =    copy.deepcopy(P.dDistnParams)
    G.dDocParams =      copy.deepcopy(P.dDocParams)
    G.dParamsParams =   copy.deepcopy(P.dParamsParams)
    dCliDict = fndCliParse(None)
    fnMaybeOverride("nSimLength",dCliDict,G)
    fnMaybeOverride("nRandomSeed",dCliDict,G)
    fnMaybeOverride("sLogLevel",dCliDict,G)
    fnMaybeOverride("sLogFile",dCliDict,G)
    fnMaybeOverride("nDocSmall",dCliDict,G)
    fnMaybeOverride("nDocLarge",dCliDict,G)
    fnMaybeOverride("nDocSmallPct",dCliDict,G)
    fnMaybeOverride("nDocPctSdev",dCliDict,G)
    fnMaybeOverride("lBER",dCliDict,G)
    fnMaybeOverride("lCopies",dCliDict,G)
    fnMaybeOverride("lShelfSize",dCliDict,G)
    fnMaybeOverride("sShortLogStr",dCliDict,G)
    fnMaybeOverride("nAuditCycleInterval",dCliDict,G)
    fnMaybeOverride("nBandwidthMbps",dCliDict,G)
    if getattr(G,"lCopies",None):
            if len(G.lCopies) >= nKey:
    if getattr(G,"lBER",None):
            if len(G.lBER) >= nKey:
    if getattr(G,"lShelfSize",None):
            if len(G.lShelfSize) >= lValue[0]:
        if getattr(G,"nDocSmall",None):
        if getattr(G,"nDocSmallPct",None):
        if getattr(G,"nDocLarge",None):
        if getattr(G,"nDocPctSdev",None):
def fnMaybeOverride(mysArg,mydDict,mycClass):
            setattr( mycClass, mysArg, mydDict[mysArg] )
            if not getattr(mycClass,mysArg,None):
                setattr( mycClass, mysArg, None )
    return getattr(mycClass,mysArg,"XXXXX")
def dumpParamsIntoLog():
def dumpServerUseStats():
        (sID,sServerID,nQual,nCapacity,nHiWater,nCurrentUse) = cShelf.mReportUseStats()
def dumpServerErrorStats():
        (sID,sServerID,nQual,nHits,nEmptyHits,bAlive,nAboveHiWater,nMultipleHits) = cShelf.mReportErrorStats()
def dumpAuditStats():
        ,nPermanentLosses,nForensicsRequired) = cAudit.mReportAuditStats()
def makeServers(mydServers):
        cServer = CServer(sServerName,nServerQual,nShelfSize)
def makeClients(mydClients):
        cClient = CClient(sClientName,mydClients[sClientName])
def testAllClients(mylClients):
        lDeadDocIDs = cClient.mTestClient()
def main():
    getCliArgsForParamDirs()
    getParamFiles(P.sFamilyDir)
        getParamFiles(sChildDir)
    getEnvironmentParams()
    getCliArgsForEverythingElse()
    lg.logSetConfig(G.sLogLevel,G.sLogFile)
    dumpParamsIntoLog()
    random.seed(G.nRandomSeed)
    env = simpy.Environment()
    G.NetworkBandwidthResource = simpy.Resource(G.env,capacity=1)
    makeServers(G.dServerParams)
    makeClients(G.dClientParams)
    dumpServerUseStats()
    tSimBegin = clock()
    env.run(until=G.nSimLength)
    tSimEnd = clock()
def evaluate():
    testAllClients(G.lAllClients)
    tWallBegin = time()
    main()
    evaluate()
    dumpServerUseStats()
    dumpServerErrorStats()
    dumpAuditStats()
    tWallEnd = time()

****** file  NewTraceFac.py
class CNewTrace:
    def __init__(self):
        self.setDefaults()
    def setDefaults(self,mylevel=0,mytarget=1,myfile="newtrace.log",myfacil=""):
    def trace(self, level, line):
            self.vecT = localtime()
                    f.write(self.linestart + " " + line + "\n")
                self.vecT = localtime()
def trace(func):
    def wrap2(*args,**kwargs):
                _id = getattr(args[0],"ID","")
TRC = CNewTrace()
****** file  readin.py
def fdGetClientParams(mysFile):
    dParams = fdGetParams(mysFile,lGuide)
def fdGetServerParams(mysFile):
    dParams = fdGetParams(mysFile,lGuide)
def fdGetQualityParams(mysFile):
    dParams = fdGetParams(mysFile,lGuide)
def fdGetParamsParams(mysFile):
    dParams = fdGetParams(mysFile,lGuide)
def fdGetDistnParams(mysFile):
    dDistn = fdGetParams(mysFile,lGuide)
def fdGetDocParams(mysFile):
    dParams = fdGetParams(mysFile,lGuide)
def fdGetAuditParams(mysFile):
    dParams = fdGetParams(mysFile,lGuide)
def fdGetParams(mysFile,mylGuide):
        fh = open(mysFile,"r")
        fh.close()
        with open(mysFile,"rb") as fhInfile:
            lLines = fhInfile.readlines()
                if re.match("^ *#",sLine) \
                or re.match("^ *$",sLine.rstrip()):
            lRowDicts = csv.DictReader(lLines)
                    dNewRow[fnIntPlease(xKey)] = fnIntPlease(dRow[xKey])

****** file  repair.py
class CRepair(object):
    def __init__(self,mysClientID):
    def mAuditCycle(self):
    def mAuditNextCollection(self):
        self.mAuditCollection(self.sCollIDLastAudited)
    def mAuditCollection(self,mysCollectionID):
    def mDocAuditAllDocsOnServer(self,mysCollectionID,mysServerID):
    def mDocAuditOnAllServers(self,mysDocID):
    def mDocAuditOneDocOnServer(self,mysCollectionID):

****** file  server.py
class CServer(object):
    def __init__(self,mysName,mynQual,mynShelfSize):
    def mAddCollection(self,mysCollID,mysClientID):
        lTempDocIDs = cCollection.mListDocuments()
            self.mAddDocument(sDocID,mysClientID)
    def mAddDocument(self,mysDocID,mysClientID):
            bResult = cShelf.mAcceptDocument(mysDocID,nSize,mysClientID)
            sNewShelfID = self.mCreateShelf()
            result = cShelf.mAcceptDocument(mysDocID,nSize,mysClientID)
    def mCreateShelf(self):
        cShelf = CShelf(self,self.nQual,self.nShelfSize)
    def mDestroyDocument(self,mysDocID,mysShelfID):
    def mTestDocument(self,mysDocID):
class CShelf(object):
    def __init__(self,mycServer,mynQual,mynCapacity):
        G.env.process(self.mAge_shelf(self.nShelfLife*1000))
        G.env.process(self.mAge_sector())
    def mAcceptDocument(self,mysDocID,mynDocSize,mysClientID):
            self.mAddDocument(mysDocID,mysClientID)
    def mAddDocument(self,mysDocID,mysClientID):
        cCopy = CCopy(mysDocID,mysClientID)
        cCopy.mShelveCopy(self.sServerID,self.ID,nBlkBegin,nBlkEnd)
        cDoc.mCopyPlacedOnServer(sCopyID,self.sServerID)
    def mAge_sector(self):
            fLifeParam = fnfCalcBlockLifetime(self.nSectorLife*1000, self.nCapacity)
            fSectorLifetime = makeexpo(fLifeParam)
            sCopyVictimID = self.mSelectVictimCopy(mynErrorSize=1)
                self.mDestroyCopy(sCopyVictimID)
                G.dID2Server[self.sServerID].mDestroyDocument(cDoc.ID,self.ID)
    def mSelectVictimCopy(self,mynErrorSize):
        nRandomSpot = makeunif(1,self.nCapacity+mynErrorSize-1)
    def mSelectVictimCopy(self,mynErrorSize):
        nRandomSpot = makeunif(1,self.nCapacity + mynErrorSize - 1)
    def mDestroyCopy(self,mysCopyID):
    def mAge_shelf(self,mynLifeParam):
        nShelfLife = makeexpo(mynLifeParam)
        templCopyIDs = copy.deepcopy(self.lCopyIDs)
            self.mDestroyCopy(sCopyID)
            G.dID2Server[self.sServerID].mDestroyDocument(sDocID,self.ID)
            self.mReportDocumentLost(sDocID)
    def mReportDocumentLost(self,mysDocID):
        cClient.mDocFailedOnServer(mysDocID,self.sServerID)
    def mReportUseStats(self):
    def mReportErrorStats(self):
class CCopy(object):
    def __init__(self,mysDocID,mysClientID):
    def mShelveCopy(self,mysServerID,mysShelfID,mynBlkBegin,mynBlkEnd):

****** file  util.py
def makeexpo(mean):
    interval = (random.expovariate(1.0/abs(mean)))
def makeunif(lo,hi):
    interval = int(random.uniform(lo,hi))
def makennnorm(mean,sdev=0):
        x = random.gauss(mean,sdev)
def fnIntPlease(oldval):
def fnnCalcDocSize(mynLevel):
    nPctRandom = makeunif(0,100)
            nDocSize = int(makennnorm(nMean,nSdev))
def fnfCalcBlockLifetime(mynSectorLife,mynCapacity):
def fnfCalcTransferTime(mynDocSize,mynBandwidth):


