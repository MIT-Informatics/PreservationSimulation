#!/usr/bin/env python3
# -*-coding: utf8-*-
# t15docase.py
'''
'''

'''
'''

'''
argv[1] = total number of cases to run; default 20.
argv[2] = max number to run simultaneously; default 8.
argv[3] = sleep interval in loop waiting for open process slot; 
            default 50 (msec).
argv[4] = max number of times to sleep waiting for an open process slot; 
            default = 100.
'''

import multiprocessing as mp
import subprocess as sp
import collections
import datetime
import re
from NewTraceFac import NTRC, ntrace, ntracef
import pathlib


# Named Tuples to communicate results of command lines.  
# Line returned from a single command
tLineOut = collections.namedtuple("tLineOut", "callstatus cmdstatus ltext ")
# List of lines returned from list of commands
tLinesOut = collections.namedtuple("tLinesOut", "procname, listoflists")
# Complete instruction info to pass to DoCase.
tInstruction = collections.namedtuple("tInstruction"
                , "cmdlist logdir logname qoutput")


# ==================== subprocess user: do one line ====================
# f n t D o O n e L i n e 
@ntracef("DO1L")
def fntDoOneLine(mysLine):
    """Execute one single-line command.  
    
    Input: single line of command.  
    Output: tuple of the (Popen PIPE return code, command return code, list
     of output lines as strings.
    Contributes line(s) to be in log file.
     Input lines and the first line of output blocks have timestamps;
     other lines in output blocks are indented with spaces.  
    """
    sTimeBegin = fnsGetTimestamp()
    proc = (sp.Popen(mysLine
        , stdout=sp.PIPE
        , close_fds=True            # The default anyway, I think.  
        , stderr=sp.DEVNULL
        , universal_newlines=True
        , shell=True)
        )
    (sProcOut, sProcErr) = proc.communicate()
    proc.stdout.close()
    if not sProcErr: sProcErr = ""
    sTimeEnd = fnsGetTimestamp()
    
    # Format lines for output by timestamping or indenting each line.  
    sOut = ("-"*len(sTimeBegin) + "\n"
            + sTimeBegin + "  " + "$ " + mysLine + "\n")
    lTmpOut1 = sProcOut.rstrip().split("\n")
    lTmpOut2 = [fnsStampLine(sTimeEnd, sLine, (i==0))
                    for i,sLine in enumerate(lTmpOut1)]
    sOut += "\n".join(lTmpOut2)
    sOut += sProcErr.rstrip()
    
    # Collect and return everything to caller.  
    nCmdStat = "n/a - RBL"
    nReturnCode = proc.returncode
    lOut = sOut.split("\n")
    
    return(tLineOut(callstatus=nReturnCode, cmdstatus=nCmdStat
        , ltext=lOut))


# ==================== multiprocessing: DoOneCase ====================
# f n t D o O n e C a s e 
@ntracef("DO1")
def fntDoOneCase(mytInstruction):
    """Input: list of instructions generated by the broker for this case; 
     multiprocessing queue through which to report results.
    
    Remove blanks, comments, etc., from the instructions.  Each line that
     is not blank or comment is a command to be executed.  Blanks and 
     comments are written directly into the output.

    Output: list of commands and their output, sent to the supplied queue.
     The text will also be written to a log file for the case.  
    
    This function will be a multiprocessing external process.
    """
    sWhoami = mp.current_process().name
    NTRC.ntracef(3, "DO1", "proc procname|%s|" % (sWhoami))
    nProc = fnsGetProcessNumber(sWhoami)
    lResults = []                   # list of strings

    # Unpack instruction command list and other items.
    lInstruction = mytInstruction.cmdlist
    (sLogfileDir, sLogfileName) = (mytInstruction.logdir
                                , mytInstruction.logname)
    qToUse = mytInstruction.qoutput
    
    # Process all command lines of the instruction list and collect results.  
    for nLine, sLine in enumerate(lInstruction):
        if fnbDoNotIgnoreLine(sLine):
            # Genuine line; execute and collect answer line(s).  
            tAnswer = fntDoOneLine(sLine)
            (nRtn, nErr, lResult) = (tAnswer.callstatus
                                    , tAnswer.cmdstatus
                                    , tAnswer.ltext)
            lResults.extend(lResult)
            NTRC.ntracef(4, "DO1", "proc DoOneCase case|%s| line|%s| "
                        "lResult|%s|" 
                        % (nProc, nLine, lResult))
        else:
            # Comment or blank line; just append to results.
            lResults.extend([("-"*len(fnsGetTimestamp()))
                            , (fnsGetTimestamp() + "  " + sLine)])
            NTRC.ntracef(4, "DO1", "proc DoOneCase case|%s| line|%s| "
                        "comment|%s|" 
                        % (nProc, nLine, sLine))
    fnWriteLogFile((lResults), sLogfileDir, sLogfileName)

    lPrefix = [("BEGIN results from " + sWhoami)]
    lSuffix = [("ENDOF results from " + sWhoami)]
    lResultsToSee = ['\n'] + lPrefix + lResults + lSuffix + ['\n']
    tAnswers = tLinesOut(procname=sWhoami, listoflists=lResultsToSee)
    qToUse.put(tAnswers)
#    qToUse.close()
    return (tAnswers)


# f n W r i t e L o g F i l e 
@ntracef("DO1")
def fnWriteLogFile(mylContents, mysFileDir, mysFileName):
    sFullName = mysFileDir + "/" + mysFileName
    # Remove file if present.
    pathToFile = pathlib.Path(sFullName)
    if pathToFile.is_file():
        pathToFile.unlink()
    # Contents should be a list of lines.
    sContents = '\n'.join(mylContents)
    with (open(sFullName, "w")) as fhOut:
        print(sContents, file=fhOut)


# f n s G e t T i m e s t a m p 
@ntracef("UTIL", level=5)
def fnsGetTimestamp():
    '''Return timestamp with milliseconds.
    '''
    return datetime.datetime.now().strftime('%Y%m%d_%H%M%S.%f')[:-3]    # with msec
#    return datetime.datetime.now().strftime('%Y%m%d_%H%M%S')           # without msec


# f n s S t a m p L i n e 
@ntracef("UTIL", level=5)
def fnsStampLine(mysStamp, mysLine, mybFirstLine):
    """To indent paras of lines where the timestamp appears only
    on the first line, blanks to indent all the others.  
    """
    if mybFirstLine:
        return fnsGetTimestamp() + "  " + mysLine
    else:
        return " "*len(fnsGetTimestamp()) + "  " + mysLine


# f n s G e t P r o c e s s N u m b e r 
@ntrace
def fnsGetProcessNumber(mysProcName):
    '''Extract the process number, which is the same as the case number
    in this case, so we can use its abbreviated form in logs and traces.
    '''
    sProcNum = re.match(".*-(\d+)", mysProcName).group(1)
    return sProcNum if sProcNum else ""












if 0:
    @ntrace
    def fnWriteLogFile(mylContents, mysFileName):
        sContents = '\n'.join(mylContents)
        with (open(mysFileName, "w")) as fhOut:
            print(sContents, file=fhOut)


# f n b D o N o t I g n o r e L i n e 
@ntracef("UTIL", level=5)
def fnbDoNotIgnoreLine(mysLine):
    '''
    True if not a comment or blank line.
    '''
    # Ignore comment and blank lines, but take all others.
    return (not re.match("^\s*#", mysLine)) and (not re.match("^\s*$", mysLine))


#END
